#include "THISDUST.H"
#include "PLANCOLL.H"


// decompiled code
// original method signature: 
// int /*$ra*/ PLANCOLL_DoesLOSExistFinal(struct _Position *startPos /*$a0*/, struct _Position *endPos /*$a1*/, int collideType /*$a2*/, int passThroughHit /*$s0*/, int zoffset /*stack 16*/)
 // line 75, offset 0x800981f0
	/* begin block 1 */
		// Start line: 76
		// Start offset: 0x800981F0
		// Variables:
	// 		struct _PCollideInfo pcollideinfo; // stack offset -72
	// 		struct SVECTOR startPt; // stack offset -24
	// 		struct SVECTOR endPt; // stack offset -16

		/* begin block 1.1 */
			// Start line: 76
			// Start offset: 0x800981F0
			// Variables:
		// 		short _x1; // $v0
		// 		short _y1; // $a2
		// 		short _z1; // $a0
		// 		struct _Position *_v0; // $v1
		/* end block 1.1 */
		// End offset: 0x800981F0
		// End Line: 76

		/* begin block 1.2 */
			// Start line: 76
			// Start offset: 0x800981F0
			// Variables:
		// 		short _x1; // $v0
		// 		short _y1; // $a0
		// 		short _z1; // $a1
		// 		struct _Position *_v0; // $v0
		/* end block 1.2 */
		// End offset: 0x800981F0
		// End Line: 76
	/* end block 1 */
	// End offset: 0x800982E4
	// End Line: 98

	/* begin block 2 */
		// Start line: 150
	/* end block 2 */
	// End Line: 151

/* File: C:\kain2\game\PLAN\PLANCOLL.C */

int PLANCOLL_DoesLOSExistFinal
              (_Position *startPos,_Position *endPos,int collideType,int passThroughHit,int zoffset)

{
  uint uVar1;
  _PCollideInfo local_48;
  SVECTOR local_18;
  SVECTOR local_10;
  
  local_18.vx = startPos->x;
  local_18.vy = startPos->y;
  local_48.oldPoint = &local_18;
  local_10.vx = endPos->x;
  local_10.vy = endPos->y;
  local_48.newPoint = &local_10;
  local_48.collideType = 0x127;
  local_48.inst = (_Instance *)0x0;
  local_48.instance = (_Instance *)0x0;
  local_18.vz = startPos->z + (short)zoffset;
  local_10.vz = endPos->z + (short)zoffset;
  COLLIDE_PointAndWorld(&local_48,(Level *)0x0);
  if ((((passThroughHit == 0) || (local_48.type != 3)) ||
      (*(ushort *)((int)local_48.prim + 10) == 0xffff)) ||
     (uVar1 = 1,
     (*(ushort *)
       ((int)&((local_48.inst)->node).prev[6].next[1].prev +
       (uint)*(ushort *)((int)local_48.prim + 10) + 2) & 0x1000) == 0)) {
    uVar1 = (uint)(local_48.type == 0);
  }
  return uVar1;
}



// decompiled code
// original method signature: 
// int /*$ra*/ PLANCOLL_CheckUnderwaterPoint(struct _Position *position /*$s5*/)
 // line 108, offset 0x800982f4
	/* begin block 1 */
		// Start line: 109
		// Start offset: 0x800982F4
		// Variables:
	// 		struct _StreamUnit *streamUnit; // $s4
	// 		struct Level *level; // $s2
	// 		struct BSPTree *tree; // $a3
	// 		struct _Sphere_noSq *sphere; // $s0
	// 		struct _Position *offset; // $a3
	// 		int d; // $s3
	// 		struct _Position center; // stack offset -40

		/* begin block 1.1 */
			// Start line: 124
			// Start offset: 0x80098358
			// Variables:
		// 		short _x1; // $v1
		// 		short _y1; // $v0
		// 		short _z1; // $a0
		// 		struct _Position *_v0; // $s6
		/* end block 1.1 */
		// End offset: 0x80098358
		// End Line: 124
	/* end block 1 */
	// End offset: 0x80098440
	// End Line: 146

	/* begin block 2 */
		// Start line: 241
	/* end block 2 */
	// End Line: 242

/* File: C:\kain2\game\PLAN\PLANCOLL.C */

int PLANCOLL_CheckUnderwaterPoint(_Position *position)

{
  long lVar1;
  short **ppsVar2;
  short *psVar3;
  int **ppiVar4;
  int *piVar5;
  int iVar6;
  int *piVar7;
  
  piVar7 = &StreamTracker;
  iVar6 = 0x10;
  ppiVar4 = (int **)&DAT_800d2a14;
  do {
    if ((*(short *)(ppiVar4 + -1) == 2) &&
       (lVar1 = MEMPACK_MemoryValidFunc((char *)*ppiVar4), lVar1 != 0)) {
      piVar5 = *ppiVar4;
      ppsVar2 = *(short ***)(*piVar5 + 0x48);
      psVar3 = *ppsVar2;
      lVar1 = MATH3D_LengthXYZ((int)position->x - (int)(short)(*psVar3 + *(short *)(ppsVar2 + 3)),
                               (int)position->y -
                               (int)(short)(psVar3[1] + *(short *)((int)ppsVar2 + 0xe)),
                               (int)position->z - (int)(short)(psVar3[2] + *(short *)(ppsVar2 + 4)))
      ;
      if ((lVar1 < (int)(uint)(ushort)psVar3[3]) && ((int)position->z < piVar5[0xe])) {
        return *piVar7;
      }
    }
    iVar6 = iVar6 + -1;
    ppiVar4 = ppiVar4 + 0x10;
    piVar7 = piVar7 + 0x10;
    if (iVar6 == 0) {
      return -1;
    }
  } while( true );
}



// autogenerated function stub: 
// int /*$ra*/ PLANCOLL_FindTerrainHitFinal(struct _PlanCollideInfo *pci /*$s5*/, int *placement /*$t0*/, int distBefore /*$s7*/, int distAfter /*$fp*/, int start /*stack 16*/, int end /*stack 20*/)
int PLANCOLL_FindTerrainHitFinal(struct _PlanCollideInfo *pci, int *placement, int distBefore, int distAfter, int start, int end)
{ // line 162, offset 0x80098468
	/* begin block 1 */
		// Start line: 163
		// Start offset: 0x80098468
		// Variables:
			struct _PCollideInfo pcollideinfo; // stack offset -120
			struct _fth *current; // $s1
			struct _fth *last; // $s6
			struct SVECTOR startPt; // stack offset -72
			struct SVECTOR endPt; // stack offset -64
			struct _SVector normal; // stack offset -56

		/* begin block 1.1 */
			// Start line: 180
			// Start offset: 0x80098504
			// Variables:
				short _x1; // $a0
				short _y1; // $v0
				short _z1; // $v1
				struct _Position *_v0; // $s4
				struct _Position *_v1; // $s2
		/* end block 1.1 */
		// End offset: 0x80098504
		// End Line: 180

		/* begin block 1.2 */
			// Start line: 180
			// Start offset: 0x80098504
			// Variables:
				short _x1; // $a1
				short _y1; // $v0
				short _z1; // $v1
				struct _Position *_v0; // $s3
		/* end block 1.2 */
		// End offset: 0x80098504
		// End Line: 180

		/* begin block 1.3 */
			// Start line: 201
			// Start offset: 0x800986C0
			// Variables:
				short _y1; // $v1
				short _z1; // $a0
		/* end block 1.3 */
		// End offset: 0x800986C0
		// End Line: 201
	/* end block 1 */
	// End offset: 0x80098700
	// End Line: 208

	/* begin block 2 */
		// Start line: 426
	/* end block 2 */
	// End Line: 427

	return 0;
}


// decompiled code
// original method signature: 
// int /*$ra*/ PLANCOLL_DoesStraightLinePathExist(struct _Position *startPos /*$s2*/, struct _Position *endPos /*$s3*/, int collideType /*$s4*/)
 // line 214, offset 0x80098730
	/* begin block 1 */
		// Start line: 215
		// Start offset: 0x80098730
	/* end block 1 */
	// End offset: 0x80098798
	// End Line: 221

	/* begin block 2 */
		// Start line: 581
	/* end block 2 */
	// End Line: 582

/* File: C:\kain2\game\PLAN\PLANCOLL.C */

int PLANCOLL_DoesStraightLinePathExist(_Position *startPos,_Position *endPos,int collideType)

{
  bool bVar1;
  int iVar2;
  uint uVar3;
  
  uVar3 = 0;
  bVar1 = DAT_800d220c < 0;
  iVar2 = PLANCOLL_DoesLOSExistFinal(startPos,endPos,collideType,(uint)bVar1,0x100);
  if (iVar2 != 0) {
    iVar2 = PLANCOLL_DoesLOSExistFinal(startPos,endPos,collideType,(uint)bVar1,0x3c0);
    uVar3 = (uint)(iVar2 != 0);
  }
  return uVar3;
}



// decompiled code
// original method signature: 
// int /*$ra*/ PLANCOLL_DoesWaterPathUpExist(struct _Position *startPos /*$s2*/, struct _Position *endPos /*$s1*/, int collideType /*$s4*/, struct _Position *peakPos /*$s3*/, int passThroughHit /*stack 16*/)
 // line 227, offset 0x800987bc
	/* begin block 1 */
		// Start line: 228
		// Start offset: 0x800987BC
		// Variables:
	// 		long time_ftop; // $s0
	// 		long time_ptow; // $a0
	// 		long time_tot; // $a1
	// 		struct _Position diff; // stack offset -32
	/* end block 1 */
	// End offset: 0x80098838
	// End Line: 246

	/* begin block 2 */
		// Start line: 619
	/* end block 2 */
	// End Line: 620

/* File: C:\kain2\game\PLAN\PLANCOLL.C */

int PLANCOLL_DoesWaterPathUpExist
              (_Position *startPos,_Position *endPos,int collideType,_Position *peakPos,
              int passThroughHit)

{
  short sVar1;
  short sVar2;
  long lVar3;
  long lVar4;
  int iVar5;
  
  lVar3 = MATH3D_FastSqrt(0x50000);
  iVar5 = ((uint)(ushort)startPos->z - (uint)(ushort)endPos->z) + 0x280;
  peakPos->z = (short)iVar5;
  lVar4 = MATH3D_FastSqrt((iVar5 * 0x20000) / 3);
  if (lVar4 < 0) {
    lVar4 = lVar4 + 0xf;
  }
  iVar5 = lVar4 >> 4;
  sVar1 = endPos->y;
  sVar2 = startPos->y;
  peakPos->x = endPos->x +
               (short)((((int)(((uint)(ushort)startPos->x - (uint)(ushort)endPos->x) * 0x10000) >>
                        0x10) * iVar5) / (lVar3 + iVar5));
  peakPos->y = endPos->y + (short)(((short)(sVar2 - sVar1) * iVar5) / (lVar3 + iVar5));
  iVar5 = PLANCOLL_DoesLOSExistFinal(startPos,peakPos,collideType,passThroughHit,0);
  return iVar5;
}





