#include "THISDUST.H"
#include "PLANCOLL.H"


// decompiled code
// original method signature: 
// int /*$ra*/ PLANCOLL_DoesLOSExistFinal(struct _Position *startPos /*$a0*/, struct _Position *endPos /*$a1*/, int collideType /*$a2*/, int passThroughHit /*$s0*/, int zoffset /*stack 16*/)
 // line 75, offset 0x80098b14
	/* begin block 1 */
		// Start line: 76
		// Start offset: 0x80098B14
		// Variables:
	// 		struct _PCollideInfo pcollideinfo; // stack offset -72
	// 		struct SVECTOR startPt; // stack offset -24
	// 		struct SVECTOR endPt; // stack offset -16

		/* begin block 1.1 */
			// Start line: 76
			// Start offset: 0x80098B14
			// Variables:
		// 		short _x1; // $v0
		// 		short _y1; // $a2
		// 		short _z1; // $a0
		// 		struct _Position *_v0; // $v1
		/* end block 1.1 */
		// End offset: 0x80098B14
		// End Line: 76

		/* begin block 1.2 */
			// Start line: 76
			// Start offset: 0x80098B14
			// Variables:
		// 		short _x1; // $v0
		// 		short _y1; // $a0
		// 		short _z1; // $a1
		// 		struct _Position *_v0; // $v0
		/* end block 1.2 */
		// End offset: 0x80098B14
		// End Line: 76
	/* end block 1 */
	// End offset: 0x80098C08
	// End Line: 98

	/* begin block 2 */
		// Start line: 150
	/* end block 2 */
	// End Line: 151

int PLANCOLL_DoesLOSExistFinal
              (_Position *startPos,_Position *endPos,int collideType,int passThroughHit,int zoffset)

{
  uint uVar1;
  _PCollideInfo local_48;
  SVECTOR local_18;
  SVECTOR local_10;
  
  local_18.vx = startPos->x;
  local_18.vy = startPos->y;
  local_48.oldPoint = &local_18;
  local_10.vx = endPos->x;
  local_10.vy = endPos->y;
  local_48.newPoint = &local_10;
  local_48.collideType = 0x127;
  local_48.inst = (_Instance *)0x0;
  local_48.instance = (_Instance *)0x0;
  local_18.vz = startPos->z + (short)zoffset;
  local_10.vz = endPos->z + (short)zoffset;
  COLLIDE_PointAndWorld(&local_48,(Level *)0x0);
  if ((((passThroughHit == 0) || (local_48.type != 3)) ||
      (*(ushort *)((int)local_48.prim + 10) == 0xffff)) ||
     (uVar1 = 1,
     (*(ushort *)
       ((int)&((local_48.inst)->node).prev[6].next[1].prev +
       (uint)*(ushort *)((int)local_48.prim + 10) + 2) & 0x1000) == 0)) {
    uVar1 = (uint)(local_48.type == 0);
  }
  return uVar1;
}



// decompiled code
// original method signature: 
// int /*$ra*/ PLANCOLL_CheckUnderwaterPoint(struct _Position *position /*$s5*/)
 // line 108, offset 0x80098c18
	/* begin block 1 */
		// Start line: 109
		// Start offset: 0x80098C18
		// Variables:
	// 		struct _StreamUnit *streamUnit; // $s4
	// 		struct Level *level; // $s2
	// 		struct BSPTree *tree; // $a3
	// 		struct _Sphere_noSq *sphere; // $s0
	// 		struct _Position *offset; // $a3
	// 		int d; // $s3
	// 		struct _Position center; // stack offset -40

		/* begin block 1.1 */
			// Start line: 124
			// Start offset: 0x80098C74
			// Variables:
		// 		short _x1; // $v1
		// 		short _y1; // $v0
		// 		short _z1; // $a0
		// 		struct _Position *_v0; // $s6
		/* end block 1.1 */
		// End offset: 0x80098C74
		// End Line: 124
	/* end block 1 */
	// End offset: 0x80098D5C
	// End Line: 146

	/* begin block 2 */
		// Start line: 241
	/* end block 2 */
	// End Line: 242

undefined4 PLANCOLL_CheckUnderwaterPoint(short *param_1)

{
  long lVar1;
  short **ppsVar2;
  short *psVar3;
  int **ppiVar4;
  int iVar5;
  
  iVar5 = 0x10;
  ppiVar4 = (int **)&gp0xffffbe74;
  while ((*(short *)(ppiVar4 + -1) != 2 ||
         (lVar1 = MEMPACK_MemoryValidFunc((char *)*ppiVar4), lVar1 == 0))) {
    iVar5 = iVar5 + -1;
    ppiVar4 = ppiVar4 + 0x10;
    if (iVar5 == 0) {
      return 0xffffffff;
    }
  }
  ppsVar2 = *(short ***)(**ppiVar4 + 0x48);
  psVar3 = *ppsVar2;
                    /* WARNING: Subroutine does not return */
  MATH3D_LengthXYZ((int)*param_1 - (int)(short)(*psVar3 + *(short *)(ppsVar2 + 3)),
                   (int)param_1[1] - (int)(short)(psVar3[1] + *(short *)((int)ppsVar2 + 0xe)),
                   (int)param_1[2] - (int)(short)(psVar3[2] + *(short *)(ppsVar2 + 4)));
}



// autogenerated function stub: 
// int /*$ra*/ PLANCOLL_FindTerrainHitFinal(struct _PlanCollideInfo *pci /*$s5*/, int *placement /*$t0*/, int distBefore /*$s7*/, int distAfter /*$fp*/, int start /*stack 16*/, int end /*stack 20*/)
int PLANCOLL_FindTerrainHitFinal(struct _PlanCollideInfo *pci, int *placement, int distBefore, int distAfter, int start, int end)
{ // line 162, offset 0x80098d84
	/* begin block 1 */
		// Start line: 163
		// Start offset: 0x80098D84
		// Variables:
			struct _PCollideInfo pcollideinfo; // stack offset -120
			struct _fth *current; // $s1
			struct _fth *last; // $s6
			struct SVECTOR startPt; // stack offset -72
			struct SVECTOR endPt; // stack offset -64
			struct _SVector normal; // stack offset -56

		/* begin block 1.1 */
			// Start line: 180
			// Start offset: 0x80098E18
			// Variables:
				short _x1; // $a0
				short _y1; // $v0
				short _z1; // $v1
				struct _Position *_v0; // $s4
				struct _Position *_v1; // $s2
		/* end block 1.1 */
		// End offset: 0x80098E18
		// End Line: 180

		/* begin block 1.2 */
			// Start line: 180
			// Start offset: 0x80098E18
			// Variables:
				short _x1; // $a1
				short _y1; // $v0
				short _z1; // $v1
				struct _Position *_v0; // $s3
		/* end block 1.2 */
		// End offset: 0x80098E18
		// End Line: 180

		/* begin block 1.3 */
			// Start line: 201
			// Start offset: 0x80098FD4
			// Variables:
				short _y1; // $v1
				short _z1; // $a0
		/* end block 1.3 */
		// End offset: 0x80098FD4
		// End Line: 201
	/* end block 1 */
	// End offset: 0x80099014
	// End Line: 208

	/* begin block 2 */
		// Start line: 426
	/* end block 2 */
	// End Line: 427

	return 0;
}


// decompiled code
// original method signature: 
// int /*$ra*/ PLANCOLL_DoesStraightLinePathExist(struct _Position *startPos /*$s2*/, struct _Position *endPos /*$s3*/, int collideType /*$s4*/)
 // line 214, offset 0x80099044
	/* begin block 1 */
		// Start line: 215
		// Start offset: 0x80099044
	/* end block 1 */
	// End offset: 0x800990AC
	// End Line: 221

	/* begin block 2 */
		// Start line: 581
	/* end block 2 */
	// End Line: 582

int PLANCOLL_DoesStraightLinePathExist(_Position *startPos,_Position *endPos,int collideType)

{
  bool bVar1;
  int iVar2;
  PlanningNode *startNode;
  PlanningNode *planningPool;
  
  bVar1 = theCamera.positionAccl._0_4_ < 0;
  startNode = (PlanningNode *)startPos;
  planningPool = (PlanningNode *)endPos;
  iVar2 = PLANCOLL_DoesLOSExistFinal(startPos,endPos,collideType,(uint)bVar1,0x100);
  if (iVar2 == 0) {
    startNode = PLANPOOL_GetClosestUnexploredValidNeighbor(startNode,planningPool);
    return (int)startNode;
  }
  iVar2 = PLANCOLL_DoesLOSExistFinal(startPos,endPos,collideType,(uint)bVar1,-0x100);
  return (uint)(iVar2 != 0);
}



// decompiled code
// original method signature: 
// int /*$ra*/ PLANCOLL_DoesWaterPathUpExist(struct _Position *startPos /*$s2*/, struct _Position *endPos /*$s1*/, int collideType /*$s4*/, struct _Position *peakPos /*$s3*/, int passThroughHit /*stack 16*/)
 // line 227, offset 0x800990d0
	/* begin block 1 */
		// Start line: 228
		// Start offset: 0x800990D0
		// Variables:
	// 		long time_ftop; // $s0
	// 		long time_ptow; // $a0
	// 		long time_tot; // $a1
	// 		struct _Position diff; // stack offset -32
	/* end block 1 */
	// End offset: 0x8009914C
	// End Line: 246

	/* begin block 2 */
		// Start line: 619
	/* end block 2 */
	// End Line: 620

int PLANCOLL_DoesWaterPathUpExist
              (_Position *startPos,_Position *endPos,int collideType,_Position *peakPos,
              int passThroughHit)

{
  short sVar1;
  short sVar2;
  long lVar3;
  long lVar4;
  int iVar5;
  
  lVar3 = MATH3D_FastSqrt(0x50000);
  iVar5 = ((uint)(ushort)startPos->z - (uint)(ushort)endPos->z) + 0x280;
  peakPos->z = (short)iVar5;
  lVar4 = MATH3D_FastSqrt((iVar5 * 0x20000) / 3);
  if (lVar4 < 0) {
    lVar4 = lVar4 + 0xf;
  }
  iVar5 = lVar4 >> 4;
  sVar1 = endPos->y;
  sVar2 = startPos->y;
  peakPos->x = endPos->x +
               (short)((((int)(((uint)(ushort)startPos->x - (uint)(ushort)endPos->x) * 0x10000) >>
                        0x10) * iVar5) / (lVar3 + iVar5));
  peakPos->y = endPos->y + (short)(((short)(sVar2 - sVar1) * iVar5) / (lVar3 + iVar5));
  iVar5 = PLANCOLL_DoesLOSExistFinal(startPos,peakPos,collideType,passThroughHit,0);
  return iVar5;
}





