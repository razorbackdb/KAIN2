#include "THISDUST.H"
#include "AADSEQEV.H"


// autogenerated function stub: 
// int /*$ra*/ aadQueueNextEvent(struct _AadSequenceSlot *slot /*$t0*/, int track /*$a1*/)
int aadQueueNextEvent(struct _AadSequenceSlot *slot, int track)
{ // line 24, offset 0x80055064
	/* begin block 1 */
		// Start line: 25
		// Start offset: 0x80055064
		// Variables:
			struct AadSeqEvent seqEvent; // stack offset -16
			unsigned char *seqData; // $a2
			unsigned long deltaTime; // $v1
			int c; // $a0
			int n; // $a3
			int i; // $a0
	/* end block 1 */
	// End offset: 0x80055254
	// End Line: 99

	/* begin block 2 */
		// Start line: 48
	/* end block 2 */
	// End Line: 49

	return 0;
}


// decompiled code
// original method signature: 
// void /*$ra*/ aadExecuteEvent(struct AadSeqEvent *event /*$s0*/, struct _AadSequenceSlot *slot /*$s1*/)
 // line 103, offset 0x8005525c
	/* begin block 1 */
		// Start line: 104
		// Start offset: 0x8005525C
		// Variables:
	// 		int eventType; // $v1
	/* end block 1 */
	// End offset: 0x800552E8
	// End Line: 123

	/* begin block 2 */
		// Start line: 210
	/* end block 2 */
	// End Line: 211

void aadExecuteEvent(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  if ((event->statusByte & 0x80) != 0) {
    aadUpdateChannelVolPan((char)event,(int)slot);
    return;
  }
  aadSubstituteVariables(event,slot);
  if (event->statusByte < 0x4e) {
    (*(code *)(&midiMetaEventFunction)[(uint)event->statusByte & 0x7f])(event,slot);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiNoteOff(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 127, offset 0x800552fc
	/* begin block 1 */
		// Start line: 258
	/* end block 1 */
	// End Line: 259

	/* begin block 2 */
		// Start line: 262
	/* end block 2 */
	// End Line: 263

void midiNoteOff(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiNoteOn(struct AadSeqEvent *event /*$fp*/, struct _AadSequenceSlot *slot /*$s5*/)
 // line 139, offset 0x80055304
	/* begin block 1 */
		// Start line: 140
		// Start offset: 0x80055304
		// Variables:
	// 		struct AadProgramAtr *progAtr; // $s4
	// 		struct AadToneAtr *toneAtrTbl; // $v1
	// 		struct AadSynthVoice *voice; // $s0
	// 		int channel; // $s7
	// 		int midiNote; // $s6
	// 		int transposedNote; // stack offset -56
	// 		int t; // $s2
	// 		int dynBank; // stack offset -52

		/* begin block 1.1 */
			// Start line: 220
			// Start offset: 0x800554E4
			// Variables:
		// 		unsigned long waveStartAddr; // $a1
		/* end block 1.1 */
		// End offset: 0x8005562C
		// End Line: 245
	/* end block 1 */
	// End offset: 0x80055648
	// End Line: 249

	/* begin block 2 */
		// Start line: 282
	/* end block 2 */
	// End Line: 283

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void midiNoteOn(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  byte bVar1;
  byte bVar2;
  uchar uVar3;
  int iVar4;
  ulong *puVar5;
  AadSynthVoice *voice;
  uint *puVar6;
  ulong waveStartAddr;
  AadToneAtr *toneAtr;
  int iVar7;
  uint uVar8;
  AadProgramAtr *progAtr;
  uint uVar9;
  uint uVar10;
  uint local_38;
  
  uVar10 = (uint)event->statusByte & 0xf;
  iVar4 = (int)&(slot->tempo).currentTick + uVar10;
  if ((((int)(uint)slot->channelMute >> uVar10 & 1U) == 0) && (*(char *)(iVar4 + 0x590) != -1)) {
    bVar1 = event->dataByte[0];
    uVar9 = (uint)bVar1;
    iVar7 = 0;
    if (event->dataByte[1] == '\0') {
      puVar6 = (uint *)&UNK_000001dc;
      do {
        if ((((uint)*(byte *)(puVar6 + 2) == (slot->slotID | uVar10)) &&
            ((uint)*(byte *)((int)puVar6 + 10) == uVar9)) &&
           ((*(char *)(iVar7 + 0x47c) != '\0' && (*(char *)(iVar7 + 0x47c) != '\x02')))) {
          _DAT_000004c4 = _DAT_000004c4 | *puVar6;
          _DAT_000004c8 = _DAT_000004c8 & ~*puVar6;
          *(undefined *)(puVar6 + 2) = 0xff;
        }
        iVar7 = iVar7 + 1;
        puVar6 = puVar6 + 7;
      } while (iVar7 < 0x18);
    }
    else {
      local_38 = uVar9;
      if (((int)(uint)slot->ignoreTranspose >> uVar10 & 1U) == 0) {
        local_38 = uVar9 + *(byte *)(iVar4 + 0x5c0) & 0xff;
      }
      iVar7 = (int)&(slot->tempo).currentTick + uVar10;
      bVar2 = *(byte *)(iVar7 + 0x560);
      iVar4 = (uint)bVar2 * 4;
      if (*(int *)(iVar4 + 0x500) == 2) {
        progAtr = (AadProgramAtr *)(*(int *)(iVar4 + 0x4d8) + (uint)*(byte *)(iVar7 + 0x590) * 8);
        uVar8 = (uint)progAtr->firstTone;
        if (uVar8 < uVar8 + progAtr->numTones) {
          puVar5 = (ulong *)((int)&(slot->tempo).currentTick + uVar10 * 2);
          toneAtr = (AadToneAtr *)(uVar8 * 0x10 + *(int *)(iVar4 + 0x4e0));
          do {
            if (((toneAtr->minNote <= uVar9) && (uVar9 <= toneAtr->maxNote)) &&
               (voice = aadAllocateVoice((uint)toneAtr->priority), voice != (AadSynthVoice *)0x0)) {
              waveStartAddr =
                   *(ulong *)((int)toneAtr->waveIndex * 4 + *(int *)((uint)bVar2 * 4 + 0x4e8));
              if ((toneAtr->pitchBendMax == '\0') || (*(short *)(puVar5 + 0x15c) == 0x2000)) {
                aadPlayTone(toneAtr,waveStartAddr,progAtr,local_38,(uint)(byte)event->dataByte[1],
                            (uint)*(byte *)(iVar7 + 0x5a0),(uint)*(byte *)(iVar7 + 0x5b0),
                            (uint)slot->slotVolume,*slot->masterVolPtr,voice,0);
                voice->handle = 0;
              }
              else {
                aadPlayTonePitchBend
                          (toneAtr,waveStartAddr,progAtr,local_38,(uint)(byte)event->dataByte[1],
                           (uint)*(byte *)(iVar7 + 0x5a0),(uint)*(byte *)(iVar7 + 0x5b0),
                           (uint)slot->slotVolume,*slot->masterVolPtr,voice,
                           (uint)*(ushort *)(puVar5 + 0x15c));
                voice->handle = 0;
              }
              voice->voiceID = slot->slotID | (byte)uVar10;
              uVar3 = toneAtr->priority;
              voice->note = bVar1;
              voice->priority = uVar3;
              voice->program = *(uchar *)(iVar7 + 0x590);
              voice->volume = event->dataByte[1];
              voice->updateVol = *(uchar *)(iVar7 + 0x5a0);
              uVar3 = *(uchar *)(iVar7 + 0x5b0);
              voice->progAtr = progAtr;
              voice->toneAtr = toneAtr;
              voice->pan = uVar3;
            }
            uVar8 = uVar8 + 1;
            toneAtr = toneAtr + 1;
          } while ((int)uVar8 < (int)((uint)progAtr->firstTone + (uint)progAtr->numTones));
        }
      }
    }
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadUpdateChannelVolPan(struct _AadSequenceSlot *slot /*$s4*/, int channel /*$s5*/)
 // line 253, offset 0x80055678
	/* begin block 1 */
		// Start line: 254
		// Start offset: 0x80055678
		// Variables:
	// 		struct AadSynthVoice *voice; // $s0
	// 		int i; // $s2
	// 		struct AadVolume newVoiceVol; // stack offset -40

		/* begin block 1.1 */
			// Start line: 267
			// Start offset: 0x80055718
			// Variables:
		// 		unsigned long tmp; // $v1
		/* end block 1.1 */
		// End offset: 0x80055718
		// End Line: 267

		/* begin block 1.2 */
			// Start line: 268
			// Start offset: 0x80055780
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.2 */
		// End offset: 0x80055780
		// End Line: 268

		/* begin block 1.3 */
			// Start line: 269
			// Start offset: 0x800557FC
			// Variables:
		// 		unsigned long tmp; // $v1
		/* end block 1.3 */
		// End offset: 0x800557FC
		// End Line: 269

		/* begin block 1.4 */
			// Start line: 270
			// Start offset: 0x80055864
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.4 */
		// End offset: 0x80055864
		// End Line: 270

		/* begin block 1.5 */
			// Start line: 270
			// Start offset: 0x80055864
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v0
		/* end block 1.5 */
		// End offset: 0x80055864
		// End Line: 270

		/* begin block 1.6 */
			// Start line: 270
			// Start offset: 0x80055864
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.6 */
		// End offset: 0x80055864
		// End Line: 270

		/* begin block 1.7 */
			// Start line: 270
			// Start offset: 0x80055864
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v0
		/* end block 1.7 */
		// End offset: 0x80055864
		// End Line: 270
	/* end block 1 */
	// End offset: 0x800559B4
	// End Line: 282

	/* begin block 2 */
		// Start line: 583
	/* end block 2 */
	// End Line: 584

void aadUpdateChannelVolPan(_AadSequenceSlot *slot,int channel)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  short local_28;
  short local_26;
  
  iVar3 = 0;
  iVar6 = (int)&(slot->tempo).currentTick + channel;
  iVar4 = 0x1dc;
  do {
    if ((uint)*(byte *)(iVar4 + 8) == ((uint)slot->slotID | channel)) {
      local_28 = (ushort)*(byte *)(iVar4 + 0xe) * (ushort)*(byte *)(iVar4 + 0xe);
      local_26 = (ushort)*(byte *)(iVar4 + 0xe) * (ushort)*(byte *)(iVar4 + 0xe);
      if (((uint)the_mcmenu_table.data_size & 1) == 0) {
        bVar1 = *(byte *)(iVar6 + 0x5b0);
        if (bVar1 < 0x41) {
          if (bVar1 < 0x3f) {
            local_26 = (short)((int)((int)local_28 * (uint)*(byte *)(iVar6 + 0x5b0) *
                                    (uint)*(byte *)(iVar6 + 0x5b0)) >> 0xc);
          }
        }
        else {
          local_28 = (short)((int)local_26 * (0x7f - (uint)bVar1) * (0x7f - (uint)bVar1) >> 0xc);
        }
      }
      uVar2 = (uint)*(byte *)(*(int *)(iVar4 + 0x14) + 2);
      iVar5 = uVar2 * uVar2;
      local_28 = (short)((uint)(local_28 * iVar5) >> 0xe);
      local_26 = (short)((uint)(local_26 * iVar5) >> 0xe);
      if (((uint)the_mcmenu_table.data_size & 1) == 0) {
        bVar1 = *(byte *)(*(int *)(iVar4 + 0x14) + 3);
        if (bVar1 < 0x41) {
          if (bVar1 < 0x3f) {
            uVar2 = (uint)*(byte *)(*(int *)(iVar4 + 0x14) + 3);
            local_26 = (short)((int)((int)local_28 * uVar2 * uVar2) >> 0xc);
          }
        }
        else {
          local_28 = (short)((int)local_26 * (0x7f - (uint)bVar1) * (0x7f - (uint)bVar1) >> 0xc);
        }
      }
      iVar6 = (uint)*(byte *)(iVar6 + 0x5a0) * (uint)*(byte *)(iVar6 + 0x5a0);
      uVar2 = (uint)*(byte *)(*(int *)(iVar4 + 0x18) + 4);
      iVar4 = uVar2 * uVar2;
      iVar5 = (uint)slot->slotVolume * (uint)slot->slotVolume;
      iVar7 = *slot->masterVolPtr * *slot->masterVolPtr;
                    /* WARNING: Subroutine does not return */
      SpuSetVoiceVolume(iVar3,(int)(short)((uint)((short)((uint)((short)((uint)((short)((uint)(
                                                  local_28 * iVar6) >> 0xe) * iVar4) >> 0xe) * iVar5
                                                  ) >> 0xe) * iVar7) >> 0xe),
                        (int)(short)((uint)((short)((uint)((short)((uint)((short)((uint)(local_26 *
                                                                                        iVar6) >>
                                                                                 0xe) * iVar4) >>
                                                                  0xe) * iVar5) >> 0xe) * iVar7) >>
                                    0xe));
    }
    iVar3 = iVar3 + 1;
    iVar4 = iVar4 + 0x1c;
  } while (iVar3 < 0x18);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadUpdateSlotVolPan(struct _AadSequenceSlot *slot /*$s1*/)
 // line 286, offset 0x800559d8
	/* begin block 1 */
		// Start line: 287
		// Start offset: 0x800559D8
		// Variables:
	// 		struct AadSynthVoice *voice; // $t0
	// 		int channel; // $t1
	// 		int i; // $s0
	// 		struct AadVolume newVoiceVol; // stack offset -24

		/* begin block 1.1 */
			// Start line: 302
			// Start offset: 0x80055A6C
			// Variables:
		// 		unsigned long tmp; // $v1
		/* end block 1.1 */
		// End offset: 0x80055A6C
		// End Line: 302

		/* begin block 1.2 */
			// Start line: 303
			// Start offset: 0x80055AD4
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.2 */
		// End offset: 0x80055AD4
		// End Line: 303

		/* begin block 1.3 */
			// Start line: 304
			// Start offset: 0x80055B50
			// Variables:
		// 		unsigned long tmp; // $v1
		/* end block 1.3 */
		// End offset: 0x80055B50
		// End Line: 304

		/* begin block 1.4 */
			// Start line: 305
			// Start offset: 0x80055BB8
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.4 */
		// End offset: 0x80055BB8
		// End Line: 305

		/* begin block 1.5 */
			// Start line: 305
			// Start offset: 0x80055BB8
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v0
		/* end block 1.5 */
		// End offset: 0x80055BB8
		// End Line: 305

		/* begin block 1.6 */
			// Start line: 305
			// Start offset: 0x80055BB8
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.6 */
		// End offset: 0x80055BB8
		// End Line: 305

		/* begin block 1.7 */
			// Start line: 305
			// Start offset: 0x80055BB8
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v0
		/* end block 1.7 */
		// End offset: 0x80055BB8
		// End Line: 305
	/* end block 1 */
	// End offset: 0x80055CF4
	// End Line: 314

	/* begin block 2 */
		// Start line: 686
	/* end block 2 */
	// End Line: 687

void aadUpdateSlotVolPan(_AadSequenceSlot *slot)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short local_18;
  short local_16;
  
  iVar4 = 0;
  iVar5 = 0x1dc;
  do {
    if (((uint)*(byte *)(iVar5 + 8) & 0xf0) == (uint)slot->slotID) {
      local_18 = (ushort)*(byte *)(iVar5 + 0xe) * (ushort)*(byte *)(iVar5 + 0xe);
      local_16 = (ushort)*(byte *)(iVar5 + 0xe) * (ushort)*(byte *)(iVar5 + 0xe);
      uVar3 = (uint)*(byte *)(iVar5 + 8) & 0xf;
      if (((uint)the_mcmenu_table.data_size & 1) == 0) {
        iVar6 = (int)&(slot->tempo).currentTick + uVar3;
        bVar1 = *(byte *)(iVar6 + 0x5b0);
        if (bVar1 < 0x41) {
          if (bVar1 < 0x3f) {
            uVar2 = (uint)*(byte *)(iVar6 + 0x5b0);
            local_16 = (short)((int)((int)local_18 * uVar2 * uVar2) >> 0xc);
          }
        }
        else {
          local_18 = (short)((int)local_16 * (0x7f - (uint)bVar1) * (0x7f - (uint)bVar1) >> 0xc);
        }
      }
      uVar2 = (uint)*(byte *)(*(int *)(iVar5 + 0x14) + 2);
      iVar6 = uVar2 * uVar2;
      local_18 = (short)((uint)(local_18 * iVar6) >> 0xe);
      local_16 = (short)((uint)(local_16 * iVar6) >> 0xe);
      if (((uint)the_mcmenu_table.data_size & 1) == 0) {
        bVar1 = *(byte *)(*(int *)(iVar5 + 0x14) + 3);
        if (bVar1 < 0x41) {
          if (bVar1 < 0x3f) {
            uVar2 = (uint)*(byte *)(*(int *)(iVar5 + 0x14) + 3);
            local_16 = (short)((int)((int)local_18 * uVar2 * uVar2) >> 0xc);
          }
        }
        else {
          local_18 = (short)((int)local_16 * (0x7f - (uint)bVar1) * (0x7f - (uint)bVar1) >> 0xc);
        }
      }
      iVar6 = (uint)slot->volume[uVar3] * (uint)slot->volume[uVar3];
      uVar3 = (uint)*(byte *)(*(int *)(iVar5 + 0x18) + 4);
      iVar5 = uVar3 * uVar3;
      iVar7 = (uint)slot->slotVolume * (uint)slot->slotVolume;
      iVar8 = *slot->masterVolPtr * *slot->masterVolPtr;
                    /* WARNING: Subroutine does not return */
      SpuSetVoiceVolume(iVar4,(int)(short)((uint)((short)((uint)((short)((uint)((short)((uint)(
                                                  local_18 * iVar6) >> 0xe) * iVar5) >> 0xe) * iVar7
                                                  ) >> 0xe) * iVar8) >> 0xe),
                        (int)(short)((uint)((short)((uint)((short)((uint)((short)((uint)(local_16 *
                                                                                        iVar6) >>
                                                                                 0xe) * iVar5) >>
                                                                  0xe) * iVar7) >> 0xe) * iVar8) >>
                                    0xe));
    }
    iVar4 = iVar4 + 1;
    iVar5 = iVar5 + 0x1c;
  } while (iVar4 < 0x18);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadUpdateChannelPitchBend(struct _AadSequenceSlot *slot /*$s5*/, int channel /*$s6*/)
 // line 318, offset 0x80055d0c
	/* begin block 1 */
		// Start line: 319
		// Start offset: 0x80055D0C
		// Variables:
	// 		struct AadSynthVoice *voice; // $a0
	// 		int i; // $s0
	// 		int finePitch; // $a1
	// 		int newPitch; // $a1
	// 		int pitchWheelPos; // $s2
	// 		int pitchIndex; // $a0
	// 		long pitchValueBendAmount; // $a2
	/* end block 1 */
	// End offset: 0x80055EA0
	// End Line: 366

	/* begin block 2 */
		// Start line: 785
	/* end block 2 */
	// End Line: 786

void aadUpdateChannelPitchBend(_AadSequenceSlot *slot,int channel)

{
  int iVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  
  iVar4 = 0;
  iVar5 = 0x1dc;
  iVar6 = (uint)slot->pitchWheel[channel] - 0x2000;
  do {
    if ((uint)*(byte *)(iVar5 + 8) == ((uint)slot->slotID | channel)) {
      iVar3 = *(int *)(iVar5 + 0x14);
      if (*(byte *)(iVar3 + 9) != 0) {
        iVar7 = 0x2000 / (int)(uint)*(byte *)(iVar3 + 9);
        iVar1 = ((uint)*(byte *)(iVar5 + 10) - ((uint)*(byte *)(iVar3 + 4) - 0x3c)) + iVar6 / iVar7;
        if ((*(byte *)(iVar3 + 5) & 0x80) == 0) {
          sVar2 = (&aadPitchTable)[iVar1] +
                  (ushort)((&aadStepsPerCent)[iVar1] * 100 * (uint)*(byte *)(iVar3 + 5) >> 0x17);
        }
        else {
          sVar2 = (&aadPitchTable)[iVar1] -
                  (ushort)((&aadStepsPerCent)[iVar1] * 100 * (0x100 - (uint)*(byte *)(iVar3 + 5)) >>
                          0x17);
        }
        SpuSetVoicePitch(iVar4,sVar2 + (short)(((int)(&aadStepsPerSemitone)[iVar1] * (iVar6 % iVar7)
                                               ) / iVar7));
      }
    }
    iVar4 = iVar4 + 1;
    iVar5 = iVar5 + 0x1c;
  } while (iVar4 < 0x18);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiPolyphonicAftertouch(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 369, offset 0x80055ec8
	/* begin block 1 */
		// Start line: 974
	/* end block 1 */
	// End Line: 975

	/* begin block 2 */
		// Start line: 975
	/* end block 2 */
	// End Line: 976

void midiPolyphonicAftertouch(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlChange(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 374, offset 0x80055ed0
	/* begin block 1 */
		// Start line: 375
		// Start offset: 0x80055ED0
		// Variables:
	// 		int controlNumber; // $v0
	/* end block 1 */
	// End offset: 0x80055ED0
	// End Line: 375

	/* begin block 2 */
		// Start line: 984
	/* end block 2 */
	// End Line: 985

void midiControlChange(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  (*(code *)(&midiControlFunction)[(uint)(byte)event->dataByte[0] & 0xf])();
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiProgramChange(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 385, offset 0x80055f10
	/* begin block 1 */
		// Start line: 387
		// Start offset: 0x80055F10
		// Variables:
	// 		int channel; // $v0
	/* end block 1 */
	// End offset: 0x80055F10
	// End Line: 389

	/* begin block 2 */
		// Start line: 1007
	/* end block 2 */
	// End Line: 1008

	/* begin block 3 */
		// Start line: 1008
	/* end block 3 */
	// End Line: 1009

	/* begin block 4 */
		// Start line: 1010
	/* end block 4 */
	// End Line: 1011

void midiProgramChange(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  slot->currentProgram[(uint)event->statusByte & 0xf] = event->dataByte[0];
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiChannelAftertouch(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 396, offset 0x80055f28
	/* begin block 1 */
		// Start line: 1030
	/* end block 1 */
	// End Line: 1031

	/* begin block 2 */
		// Start line: 1031
	/* end block 2 */
	// End Line: 1032

void midiChannelAftertouch(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiPitchWheelControl(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a3*/)
 // line 401, offset 0x80055f30
	/* begin block 1 */
		// Start line: 402
		// Start offset: 0x80055F30
		// Variables:
	// 		int channel; // $a1
	/* end block 1 */
	// End offset: 0x80055F30
	// End Line: 402

	/* begin block 2 */
		// Start line: 1040
	/* end block 2 */
	// End Line: 1041

void midiPitchWheelControl(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  uint channel;
  
  channel = (uint)event->statusByte & 0xf;
  slot->pitchWheel[channel] =
       (ushort)(byte)event->dataByte[0] | (ushort)(byte)event->dataByte[1] << 7;
  aadUpdateChannelPitchBend(slot,channel);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiMetaEvent(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 413, offset 0x80055f78
	/* begin block 1 */
		// Start line: 1067
	/* end block 1 */
	// End Line: 1068

	/* begin block 2 */
		// Start line: 1070
	/* end block 2 */
	// End Line: 1071

void midiMetaEvent(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlBankSelect(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 421, offset 0x80055f80
	/* begin block 1 */
		// Start line: 1083
	/* end block 1 */
	// End Line: 1084

	/* begin block 2 */
		// Start line: 1104
	/* end block 2 */
	// End Line: 1105

void midiControlBankSelect(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlVolume(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a2*/)
 // line 446, offset 0x80055f88
	/* begin block 1 */
		// Start line: 447
		// Start offset: 0x80055F88
		// Variables:
	// 		int channel; // $a1
	/* end block 1 */
	// End offset: 0x80055FC8
	// End Line: 458

	/* begin block 2 */
		// Start line: 1133
	/* end block 2 */
	// End Line: 1134

void midiControlVolume(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  uint channel;
  
  channel = (uint)event->statusByte & 0xf;
  slot->volume[channel] = event->dataByte[1];
  if (((int)(uint)slot->enableSustainUpdate >> channel & 1U) != 0) {
                    /* WARNING: Subroutine does not return */
    aadUpdateChannelVolPan(slot,channel);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlPan(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a2*/)
 // line 461, offset 0x80055fd8
	/* begin block 1 */
		// Start line: 462
		// Start offset: 0x80055FD8
		// Variables:
	// 		int channel; // $a1
	/* end block 1 */
	// End offset: 0x80056018
	// End Line: 473

	/* begin block 2 */
		// Start line: 1164
	/* end block 2 */
	// End Line: 1165

void midiControlPan(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  uint channel;
  
  channel = (uint)event->statusByte & 0xf;
  slot->panPosition[channel] = event->dataByte[1];
  if (((int)(uint)slot->enableSustainUpdate >> channel & 1U) != 0) {
                    /* WARNING: Subroutine does not return */
    aadUpdateChannelVolPan(slot,channel);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlCallback(struct AadSeqEvent *event /*$a3*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 476, offset 0x80056028
	/* begin block 1 */
		// Start line: 477
		// Start offset: 0x80056028
	/* end block 1 */
	// End offset: 0x8005605C
	// End Line: 488

	/* begin block 2 */
		// Start line: 1195
	/* end block 2 */
	// End Line: 1196

	/* begin block 3 */
		// Start line: 1198
	/* end block 3 */
	// End Line: 1199

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void midiControlCallback(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  if (_DAT_00001bf8 != (code *)0x0) {
    (*_DAT_00001bf8)(_DAT_00001c00,(uint)slot->thisSlotNumber,(uint)event->statusByte & 0xf,
                     (uint)(byte)event->dataByte[1]);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlDummy(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 491, offset 0x8005606c
	/* begin block 1 */
		// Start line: 1228
	/* end block 1 */
	// End Line: 1229

	/* begin block 2 */
		// Start line: 1229
	/* end block 2 */
	// End Line: 1230

void midiControlDummy(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}





