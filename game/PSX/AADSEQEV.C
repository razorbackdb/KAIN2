#include "THISDUST.H"
#include "AADSEQEV.H"


// autogenerated function stub: 
// int /*$ra*/ aadQueueNextEvent(struct _AadSequenceSlot *slot /*$t0*/, int track /*$a1*/)
int aadQueueNextEvent(struct _AadSequenceSlot *slot, int track)
{ // line 24, offset 0x80055f34
	/* begin block 1 */
		// Start line: 25
		// Start offset: 0x80055F34
		// Variables:
			struct AadSeqEvent seqEvent; // stack offset -16
			unsigned char *seqData; // $a2
			unsigned long deltaTime; // $v1
			int c; // $a0
			int n; // $a3
			int i; // $a0
	/* end block 1 */
	// End offset: 0x80056124
	// End Line: 99

	/* begin block 2 */
		// Start line: 48
	/* end block 2 */
	// End Line: 49

	return 0;
}


// decompiled code
// original method signature: 
// void /*$ra*/ aadExecuteEvent(struct AadSeqEvent *event /*$s0*/, struct _AadSequenceSlot *slot /*$s1*/)
 // line 103, offset 0x8005612c
	/* begin block 1 */
		// Start line: 104
		// Start offset: 0x8005612C
		// Variables:
	// 		unsigned short eventType; // $v1
	/* end block 1 */
	// End offset: 0x800561BC
	// End Line: 123

	/* begin block 2 */
		// Start line: 210
	/* end block 2 */
	// End Line: 211

void aadExecuteEvent(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  code *pcVar1;
  
  if ((event->statusByte & 0x80) == 0) {
    aadSubstituteVariables(event,slot);
    if (0x4b < event->statusByte) {
      return;
    }
    pcVar1 = (code *)(&midiMetaEventFunction)[(uint)event->statusByte & 0x7f];
  }
  else {
    pcVar1 = *(code **)((int)&midiEventFunction + ((uint)(event->statusByte >> 2) & 0x1c));
  }
  (*pcVar1)(event,slot);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiNoteOff(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 127, offset 0x800561d0
	/* begin block 1 */
		// Start line: 258
	/* end block 1 */
	// End Line: 259

	/* begin block 2 */
		// Start line: 262
	/* end block 2 */
	// End Line: 263

void midiNoteOff(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiNoteOn(struct AadSeqEvent *event /*stack 0*/, struct _AadSequenceSlot *slot /*$s5*/)
 // line 139, offset 0x800561d8
	/* begin block 1 */
		// Start line: 140
		// Start offset: 0x800561D8
		// Variables:
	// 		struct AadProgramAtr *progAtr; // $s4
	// 		struct AadToneAtr *toneAtrTbl; // stack offset -56
	// 		struct AadToneAtr *toneAtr; // $s1
	// 		struct AadSynthVoice *voice; // $s0
	// 		int channel; // $s7
	// 		int midiNote; // $s6
	// 		int transposedNote; // stack offset -52
	// 		unsigned short t; // $s3

		/* begin block 1.1 */
			// Start line: 219
			// Start offset: 0x800563EC
			// Variables:
		// 		unsigned long waveStartAddr; // $a1
		/* end block 1.1 */
		// End offset: 0x80056540
		// End Line: 244
	/* end block 1 */
	// End offset: 0x80056560
	// End Line: 248

	/* begin block 2 */
		// Start line: 282
	/* end block 2 */
	// End Line: 283

void midiNoteOn(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  byte bVar1;
  uchar uVar2;
  int iVar3;
  AadSynthVoice *voice;
  int iVar4;
  uint uVar5;
  ulong waveStartAddr;
  int iVar6;
  AadToneAtr *toneAtr;
  ushort uVar7;
  uint uVar8;
  AadProgramAtr *progAtr;
  uint uVar9;
  uint uVar10;
  ulong *puVar11;
  uint local_34;
  
  uVar10 = (uint)event->statusByte & 0xf;
  iVar3 = (int)&(slot->tempo).currentTick + uVar10;
  if ((((int)(uint)slot->channelMute >> uVar10 & 1U) == 0) && (*(char *)(iVar3 + 0x584) != -1)) {
    bVar1 = event->dataByte[0];
    uVar9 = (uint)bVar1;
    uVar7 = 0;
    if (event->dataByte[1] == '\0') {
      uVar5 = 0;
      while( true ) {
        iVar3 = uVar5 * 0x1c;
        if ((((uint)*(byte *)(iVar3 + 0x1cc) ==
              (*(byte *)((int)&slot->delayedUnMuteCmds + 1) | uVar10)) &&
            ((uint)*(byte *)(iVar3 + 0x1ce) == uVar9)) &&
           ((*(char *)(uVar5 + 0x464) != '\0' && (*(char *)(uVar5 + 0x464) != '\x02')))) {
          uRam000004ac = uRam000004ac | *(uint *)(iVar3 + 0x1c4);
          uRam000004b0 = uRam000004b0 & ~*(uint *)(iVar3 + 0x1c4);
          *(undefined *)(iVar3 + 0x1cc) = 0xff;
        }
        uVar7 = uVar7 + 1;
        if (0x17 < uVar7) break;
        uVar5 = (uint)uVar7;
      }
    }
    else {
      local_34 = uVar9;
      if (((int)(uint)slot->delayedMuteCmds >> uVar10 & 1U) == 0) {
        local_34 = uVar9 + *(byte *)(iVar3 + 0x5c4) & 0xff;
      }
      iVar3 = (int)&(slot->tempo).currentTick + uVar10;
      iVar6 = (uint)*(byte *)(iVar3 + 0x554) * 4;
      if (*(char *)((uint)*(byte *)(iVar3 + 0x554) + 0x4e8) == '\x02') {
        iVar4 = *(int *)(iVar6 + 0x4c8);
        progAtr = (AadProgramAtr *)
                  (*(int *)(iVar6 + 0x4c0) +
                  ((uint)*(byte *)(iVar3 + 0x584) + (uint)*(byte *)(iVar3 + 0x594)) * 8);
        uVar5 = (uint)progAtr->firstTone;
        if (uVar5 < uVar5 + progAtr->numTones) {
          puVar11 = (ulong *)((int)&(slot->tempo).currentTick + uVar10 * 2);
          uVar8 = uVar5;
          do {
            toneAtr = (AadToneAtr *)(iVar4 + uVar5 * 0x10);
            if (((toneAtr->minNote <= uVar9) && (uVar9 <= toneAtr->maxNote)) &&
               (voice = aadAllocateVoice((uint)toneAtr->priority), voice != (AadSynthVoice *)0x0)) {
              waveStartAddr = *(ulong *)((int)toneAtr->waveIndex * 4 + *(int *)(iVar6 + 0x4d0));
              if ((toneAtr->pitchBendMax == '\0') || (*(short *)(puVar11 + 0x159) == 0x2000)) {
                aadPlayTone(toneAtr,waveStartAddr,progAtr,local_34,(uint)(byte)event->dataByte[1],
                            (uint)*(byte *)(iVar3 + 0x5a4),(uint)*(byte *)(iVar3 + 0x5b4),
                            (uint)*(byte *)&slot->unused,(uint)**(byte **)&slot->enableSustainUpdate
                            ,voice,0);
                voice->handle = 0;
              }
              else {
                aadPlayTonePitchBend
                          (toneAtr,waveStartAddr,progAtr,local_34,(uint)(byte)event->dataByte[1],
                           (uint)*(byte *)(iVar3 + 0x5a4),(uint)*(byte *)(iVar3 + 0x5b4),
                           (uint)*(byte *)&slot->unused,(uint)**(byte **)&slot->enableSustainUpdate,
                           voice,(uint)*(ushort *)(puVar11 + 0x159));
                voice->handle = 0;
              }
              voice->voiceID = *(byte *)((int)&slot->delayedUnMuteCmds + 1) | (byte)uVar10;
              uVar2 = toneAtr->priority;
              voice->note = bVar1;
              voice->priority = uVar2;
              voice->program = *(uchar *)(iVar3 + 0x584);
              voice->volume = event->dataByte[1];
              voice->updateVol = *(uchar *)(iVar3 + 0x5a4);
              uVar2 = *(uchar *)(iVar3 + 0x5b4);
              voice->progAtr = progAtr;
              voice->toneAtr = toneAtr;
              voice->pan = uVar2;
            }
            uVar8 = uVar8 + 1;
            uVar5 = uVar8 & 0xffff;
          } while (uVar5 < (uint)progAtr->firstTone + (uint)progAtr->numTones);
        }
      }
    }
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadUpdateChannelVolPan(struct _AadSequenceSlot *slot /*$s4*/, int channel /*$s5*/)
 // line 252, offset 0x80056590
	/* begin block 1 */
		// Start line: 253
		// Start offset: 0x80056590
		// Variables:
	// 		struct AadSynthVoice *voice; // $s0
	// 		int i; // $s2
	// 		struct AadVolume newVoiceVol; // stack offset -40

		/* begin block 1.1 */
			// Start line: 266
			// Start offset: 0x80056630
			// Variables:
		// 		unsigned long tmp; // $v1
		/* end block 1.1 */
		// End offset: 0x80056630
		// End Line: 266

		/* begin block 1.2 */
			// Start line: 267
			// Start offset: 0x80056698
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.2 */
		// End offset: 0x80056698
		// End Line: 267

		/* begin block 1.3 */
			// Start line: 268
			// Start offset: 0x80056714
			// Variables:
		// 		unsigned long tmp; // $v1
		/* end block 1.3 */
		// End offset: 0x80056714
		// End Line: 268

		/* begin block 1.4 */
			// Start line: 269
			// Start offset: 0x8005677C
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.4 */
		// End offset: 0x8005677C
		// End Line: 269

		/* begin block 1.5 */
			// Start line: 269
			// Start offset: 0x8005677C
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v0
		/* end block 1.5 */
		// End offset: 0x8005677C
		// End Line: 269

		/* begin block 1.6 */
			// Start line: 269
			// Start offset: 0x8005677C
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.6 */
		// End offset: 0x8005677C
		// End Line: 269

		/* begin block 1.7 */
			// Start line: 269
			// Start offset: 0x8005677C
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v0
		/* end block 1.7 */
		// End offset: 0x8005677C
		// End Line: 269
	/* end block 1 */
	// End offset: 0x800568CC
	// End Line: 281

	/* begin block 2 */
		// Start line: 570
	/* end block 2 */
	// End Line: 571

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void aadUpdateChannelVolPan(_AadSequenceSlot *slot,int channel)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  short local_28;
  short local_26;
  
  iVar4 = 0;
  iVar3 = (int)&(slot->tempo).currentTick + channel;
  iVar5 = 0x1c4;
  do {
    if ((uint)*(byte *)(iVar5 + 8) == ((uint)*(byte *)((int)&slot->delayedUnMuteCmds + 1) | channel)
       ) {
      local_28 = (ushort)*(byte *)(iVar5 + 0xe) * (ushort)*(byte *)(iVar5 + 0xe);
      local_26 = (ushort)*(byte *)(iVar5 + 0xe) * (ushort)*(byte *)(iVar5 + 0xe);
      if ((_DAT_00000012 & 1) == 0) {
        bVar1 = *(byte *)(iVar3 + 0x5b4);
        if (bVar1 < 0x41) {
          if (bVar1 < 0x3f) {
            local_26 = (short)((int)((int)local_28 * (uint)*(byte *)(iVar3 + 0x5b4) *
                                    (uint)*(byte *)(iVar3 + 0x5b4)) >> 0xc);
          }
        }
        else {
          local_28 = (short)((int)local_26 * (0x7f - (uint)bVar1) * (0x7f - (uint)bVar1) >> 0xc);
        }
      }
      uVar2 = (uint)*(byte *)(*(int *)(iVar5 + 0x14) + 2);
      iVar6 = uVar2 * uVar2;
      local_28 = (short)((uint)(local_28 * iVar6) >> 0xe);
      local_26 = (short)((uint)(local_26 * iVar6) >> 0xe);
      if ((_DAT_00000012 & 1) == 0) {
        bVar1 = *(byte *)(*(int *)(iVar5 + 0x14) + 3);
        if (bVar1 < 0x41) {
          if (bVar1 < 0x3f) {
            uVar2 = (uint)*(byte *)(*(int *)(iVar5 + 0x14) + 3);
            local_26 = (short)((int)((int)local_28 * uVar2 * uVar2) >> 0xc);
          }
        }
        else {
          local_28 = (short)((int)local_26 * (0x7f - (uint)bVar1) * (0x7f - (uint)bVar1) >> 0xc);
        }
      }
      iVar6 = (uint)*(byte *)(iVar3 + 0x5a4) * (uint)*(byte *)(iVar3 + 0x5a4);
      uVar2 = (uint)*(byte *)(*(int *)(iVar5 + 0x18) + 4);
      iVar7 = uVar2 * uVar2;
      iVar8 = (uint)*(byte *)&slot->unused * (uint)*(byte *)&slot->unused;
      iVar9 = (uint)**(byte **)&slot->enableSustainUpdate *
              (uint)**(byte **)&slot->enableSustainUpdate;
      SpuSetVoiceVolume(iVar4,(int)(short)((uint)((short)((uint)((short)((uint)((short)((uint)(
                                                  local_28 * iVar6) >> 0xe) * iVar7) >> 0xe) * iVar8
                                                  ) >> 0xe) * iVar9) >> 0xe),
                        (int)(short)((uint)((short)((uint)((short)((uint)((short)((uint)(local_26 *
                                                                                        iVar6) >>
                                                                                 0xe) * iVar7) >>
                                                                  0xe) * iVar8) >> 0xe) * iVar9) >>
                                    0xe));
      *(undefined *)(iVar5 + 0xf) = *(undefined *)(iVar3 + 0x5a4);
      *(undefined *)(iVar5 + 0x10) = *(undefined *)(iVar3 + 0x5b4);
    }
    iVar4 = iVar4 + 1;
    iVar5 = iVar5 + 0x1c;
  } while (iVar4 < 0x18);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadUpdateSlotVolPan(struct _AadSequenceSlot *slot /*$s1*/)
 // line 285, offset 0x800568f0
	/* begin block 1 */
		// Start line: 286
		// Start offset: 0x800568F0
		// Variables:
	// 		struct AadSynthVoice *voice; // $t0
	// 		unsigned short channel; // $t1
	// 		unsigned short i; // $s0
	// 		struct AadVolume newVoiceVol; // stack offset -24

		/* begin block 1.1 */
			// Start line: 301
			// Start offset: 0x8005698C
			// Variables:
		// 		unsigned long tmp; // $v1
		/* end block 1.1 */
		// End offset: 0x8005698C
		// End Line: 301

		/* begin block 1.2 */
			// Start line: 302
			// Start offset: 0x800569F4
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.2 */
		// End offset: 0x800569F4
		// End Line: 302

		/* begin block 1.3 */
			// Start line: 303
			// Start offset: 0x80056A70
			// Variables:
		// 		unsigned long tmp; // $v1
		/* end block 1.3 */
		// End offset: 0x80056A70
		// End Line: 303

		/* begin block 1.4 */
			// Start line: 304
			// Start offset: 0x80056AD8
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.4 */
		// End offset: 0x80056AD8
		// End Line: 304

		/* begin block 1.5 */
			// Start line: 304
			// Start offset: 0x80056AD8
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v0
		/* end block 1.5 */
		// End offset: 0x80056AD8
		// End Line: 304

		/* begin block 1.6 */
			// Start line: 304
			// Start offset: 0x80056AD8
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.6 */
		// End offset: 0x80056AD8
		// End Line: 304

		/* begin block 1.7 */
			// Start line: 304
			// Start offset: 0x80056AD8
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v0
		/* end block 1.7 */
		// End offset: 0x80056AD8
		// End Line: 304
	/* end block 1 */
	// End offset: 0x80056C18
	// End Line: 313

	/* begin block 2 */
		// Start line: 673
	/* end block 2 */
	// End Line: 674

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void aadUpdateSlotVolPan(_AadSequenceSlot *slot)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  ushort uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short local_18;
  short local_16;
  
  uVar5 = 0;
  uVar3 = 0;
  do {
    iVar2 = uVar3 * 0x1c;
    uVar3 = (uint)*(byte *)(iVar2 + 0x1cc) & 0xf;
    if (((uint)*(byte *)(iVar2 + 0x1cc) & 0xf0) ==
        (uint)*(byte *)((int)&slot->delayedUnMuteCmds + 1)) {
      local_18 = (ushort)*(byte *)(iVar2 + 0x1d2) * (ushort)*(byte *)(iVar2 + 0x1d2);
      local_16 = (ushort)*(byte *)(iVar2 + 0x1d2) * (ushort)*(byte *)(iVar2 + 0x1d2);
      if ((_DAT_00000012 & 1) == 0) {
        iVar6 = (int)&(slot->tempo).currentTick + uVar3;
        bVar1 = *(byte *)(iVar6 + 0x5b4);
        if (bVar1 < 0x41) {
          if (bVar1 < 0x3f) {
            uVar4 = (uint)*(byte *)(iVar6 + 0x5b4);
            local_16 = (short)((int)((int)local_18 * uVar4 * uVar4) >> 0xc);
          }
        }
        else {
          local_18 = (short)((int)local_16 * (0x7f - (uint)bVar1) * (0x7f - (uint)bVar1) >> 0xc);
        }
      }
      uVar4 = (uint)*(byte *)(*(int *)(iVar2 + 0x1d8) + 2);
      iVar6 = uVar4 * uVar4;
      local_18 = (short)((uint)(local_18 * iVar6) >> 0xe);
      local_16 = (short)((uint)(local_16 * iVar6) >> 0xe);
      if ((_DAT_00000012 & 1) == 0) {
        bVar1 = *(byte *)(*(int *)(iVar2 + 0x1d8) + 3);
        if (bVar1 < 0x41) {
          if (bVar1 < 0x3f) {
            uVar4 = (uint)*(byte *)(*(int *)(iVar2 + 0x1d8) + 3);
            local_16 = (short)((int)((int)local_18 * uVar4 * uVar4) >> 0xc);
          }
        }
        else {
          local_18 = (short)((int)local_16 * (0x7f - (uint)bVar1) * (0x7f - (uint)bVar1) >> 0xc);
        }
      }
      iVar6 = (uint)slot->volume[uVar3 + 4] * (uint)slot->volume[uVar3 + 4];
      uVar3 = (uint)*(byte *)(*(int *)(iVar2 + 0x1dc) + 4);
      iVar2 = uVar3 * uVar3;
      iVar7 = (uint)*(byte *)&slot->unused * (uint)*(byte *)&slot->unused;
      iVar8 = (uint)**(byte **)&slot->enableSustainUpdate *
              (uint)**(byte **)&slot->enableSustainUpdate;
      SpuSetVoiceVolume((uint)uVar5,
                        (int)(short)((uint)((short)((uint)((short)((uint)((short)((uint)(local_18 *
                                                                                        iVar6) >>
                                                                                 0xe) * iVar2) >>
                                                                  0xe) * iVar7) >> 0xe) * iVar8) >>
                                    0xe),
                        (int)(short)((uint)((short)((uint)((short)((uint)((short)((uint)(local_16 *
                                                                                        iVar6) >>
                                                                                 0xe) * iVar2) >>
                                                                  0xe) * iVar7) >> 0xe) * iVar8) >>
                                    0xe));
    }
    uVar5 = uVar5 + 1;
    uVar3 = (uint)uVar5;
  } while (uVar5 < 0x18);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadUpdateChannelPitchBend(struct _AadSequenceSlot *slot /*$s3*/, int channel /*$s4*/)
 // line 317, offset 0x80056c2c
	/* begin block 1 */
		// Start line: 318
		// Start offset: 0x80056C2C
		// Variables:
	// 		struct AadSynthVoice *voice; // $a3
	// 		int i; // $s0
	// 		unsigned short finePitch; // $a0
	// 		unsigned short newPitch; // $a1
	// 		long pitchValueBendAmount; // $a2
	/* end block 1 */
	// End offset: 0x80056DE4
	// End Line: 365

	/* begin block 2 */
		// Start line: 771
	/* end block 2 */
	// End Line: 772

void aadUpdateChannelPitchBend(_AadSequenceSlot *slot,int channel)

{
  short sVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  
  iVar4 = 0;
  iVar5 = 0x1c4;
  iVar6 = (int)(((uint)*(ushort *)(slot->currentDynamicBank + channel * 2 + 4) - 0x2000) * 0x10000)
          >> 0x10;
  do {
    if ((uint)*(byte *)(iVar5 + 8) == ((uint)*(byte *)((int)&slot->delayedUnMuteCmds + 1) | channel)
       ) {
      iVar3 = *(int *)(iVar5 + 0x14);
      if (*(byte *)(iVar3 + 9) != 0) {
        iVar7 = 0x2000 / (int)(uint)*(byte *)(iVar3 + 9);
        iVar2 = (int)(((((uint)*(byte *)(iVar5 + 10) + 0x3c) - (uint)*(byte *)(iVar3 + 4)) +
                      iVar6 / iVar7) * 0x10000) >> 0x10;
        if ((*(byte *)(iVar3 + 5) & 0x80) == 0) {
          sVar1 = (&aadPitchTable)[iVar2] +
                  (ushort)((&aadStepsPerCent)[iVar2] * 100 * (uint)*(byte *)(iVar3 + 5) >> 0x17);
        }
        else {
          sVar1 = (&aadPitchTable)[iVar2] -
                  (ushort)((&aadStepsPerCent)[iVar2] * 100 *
                           (0x100 - (uint)*(byte *)(iVar3 + 5) & 0xffff) >> 0x17);
        }
        SpuSetVoicePitch(iVar4,sVar1 + (short)(((int)(&aadStepsPerSemitone)[iVar2] * (iVar6 % iVar7)
                                               ) / iVar7));
      }
    }
    iVar4 = iVar4 + 1;
    iVar5 = iVar5 + 0x1c;
  } while (iVar4 < 0x18);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiPolyphonicAftertouch(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 368, offset 0x80056e04
	/* begin block 1 */
		// Start line: 934
	/* end block 1 */
	// End Line: 935

	/* begin block 2 */
		// Start line: 935
	/* end block 2 */
	// End Line: 936

void midiPolyphonicAftertouch(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlChange(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 373, offset 0x80056e0c
	/* begin block 1 */
		// Start line: 374
		// Start offset: 0x80056E0C
		// Variables:
	// 		int controlNumber; // $v0
	/* end block 1 */
	// End offset: 0x80056E0C
	// End Line: 374

	/* begin block 2 */
		// Start line: 944
	/* end block 2 */
	// End Line: 945

void midiControlChange(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  (*(code *)(&midiControlFunction)[(uint)(byte)event->dataByte[0] & 0xf])();
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiProgramChange(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 384, offset 0x80056e4c
	/* begin block 1 */
		// Start line: 386
		// Start offset: 0x80056E4C
		// Variables:
	// 		int channel; // $v0
	/* end block 1 */
	// End offset: 0x80056E4C
	// End Line: 388

	/* begin block 2 */
		// Start line: 967
	/* end block 2 */
	// End Line: 968

	/* begin block 3 */
		// Start line: 968
	/* end block 3 */
	// End Line: 969

	/* begin block 4 */
		// Start line: 970
	/* end block 4 */
	// End Line: 971

void midiProgramChange(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  *(char *)((int)slot->pitchWheel + ((uint)event->statusByte & 0xf) + 0x14) = event->dataByte[0];
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiChannelAftertouch(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 395, offset 0x80056e64
	/* begin block 1 */
		// Start line: 990
	/* end block 1 */
	// End Line: 991

	/* begin block 2 */
		// Start line: 991
	/* end block 2 */
	// End Line: 992

void midiChannelAftertouch(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiPitchWheelControl(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a3*/)
 // line 400, offset 0x80056e6c
	/* begin block 1 */
		// Start line: 401
		// Start offset: 0x80056E6C
		// Variables:
	// 		int channel; // $a1
	/* end block 1 */
	// End offset: 0x80056E6C
	// End Line: 401

	/* begin block 2 */
		// Start line: 1000
	/* end block 2 */
	// End Line: 1001

void midiPitchWheelControl(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  uint channel;
  
  channel = (uint)event->statusByte & 0xf;
  *(ushort *)(slot->currentDynamicBank + channel * 2 + 4) =
       (ushort)(byte)event->dataByte[0] | (ushort)(byte)event->dataByte[1] << 7;
  aadUpdateChannelPitchBend(slot,channel);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiMetaEvent(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 412, offset 0x80056eb4
	/* begin block 1 */
		// Start line: 1027
	/* end block 1 */
	// End Line: 1028

	/* begin block 2 */
		// Start line: 1030
	/* end block 2 */
	// End Line: 1031

void midiMetaEvent(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlBankSelect(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$v1*/)
 // line 420, offset 0x80056ebc
	/* begin block 1 */
		// Start line: 421
		// Start offset: 0x80056EBC
		// Variables:
	// 		int channel; // $a1
	// 		int bank; // $a3

		/* begin block 1.1 */
			// Start line: 430
			// Start offset: 0x80056ED8
		/* end block 1.1 */
		// End offset: 0x80056F14
		// End Line: 435
	/* end block 1 */
	// End offset: 0x80056F14
	// End Line: 441

	/* begin block 2 */
		// Start line: 1043
	/* end block 2 */
	// End Line: 1044

void midiControlBankSelect(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  uint uVar1;
  int iVar2;
  
  iVar2 = (int)&(slot->tempo).currentTick + ((uint)event->statusByte & 0xf);
  if ((byte)event->dataByte[1] < 0x10) {
    uVar1 = (uint)*(byte *)(iVar2 + 0x554);
    if (*(char *)(uVar1 + 0x4e8) == '\x02') {
      *(undefined *)(iVar2 + 0x594) =
           *(undefined *)(*(int *)(uVar1 * 4 + 0x4b8) + (uint)(byte)event->dataByte[1] + 0x50);
    }
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlVolume(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a2*/)
 // line 444, offset 0x80056f1c
	/* begin block 1 */
		// Start line: 445
		// Start offset: 0x80056F1C
		// Variables:
	// 		int channel; // $a1
	/* end block 1 */
	// End offset: 0x80056F5C
	// End Line: 456

	/* begin block 2 */
		// Start line: 1092
	/* end block 2 */
	// End Line: 1093

void midiControlVolume(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  uint channel;
  
  channel = (uint)event->statusByte & 0xf;
  slot->volume[channel + 4] = event->dataByte[1];
  if (((int)(uint)slot->delayedMuteMode >> channel & 1U) != 0) {
    aadUpdateChannelVolPan(slot,channel);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlPan(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a2*/)
 // line 459, offset 0x80056f6c
	/* begin block 1 */
		// Start line: 460
		// Start offset: 0x80056F6C
		// Variables:
	// 		int channel; // $a1
	/* end block 1 */
	// End offset: 0x80056FAC
	// End Line: 471

	/* begin block 2 */
		// Start line: 1123
	/* end block 2 */
	// End Line: 1124

void midiControlPan(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  uint channel;
  
  channel = (uint)event->statusByte & 0xf;
  slot->panPosition[channel + 4] = event->dataByte[1];
  if (((int)(uint)slot->delayedMuteMode >> channel & 1U) != 0) {
    aadUpdateChannelVolPan(slot,channel);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlCallback(struct AadSeqEvent *event /*$a3*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 474, offset 0x80056fbc
	/* begin block 1 */
		// Start line: 475
		// Start offset: 0x80056FBC
	/* end block 1 */
	// End offset: 0x80056FF0
	// End Line: 486

	/* begin block 2 */
		// Start line: 1154
	/* end block 2 */
	// End Line: 1155

	/* begin block 3 */
		// Start line: 1157
	/* end block 3 */
	// End Line: 1158

void midiControlCallback(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  if (pcRam00001b5c != (code *)0x0) {
    (*pcRam00001b5c)(uRam00001b64,(uint)slot->thisSlotNumber,(uint)event->statusByte & 0xf,
                     (uint)(byte)event->dataByte[1]);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlDummy(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 489, offset 0x80057000
	/* begin block 1 */
		// Start line: 1187
	/* end block 1 */
	// End Line: 1188

	/* begin block 2 */
		// Start line: 1188
	/* end block 2 */
	// End Line: 1189

void midiControlDummy(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}





