
#include "AADSEQEV.H"


// autogenerated function stub: 
// int /*$ra*/ aadQueueNextEvent(struct _AadSequenceSlot *slot /*$t0*/, int track /*$a1*/)
int aadQueueNextEvent(struct _AadSequenceSlot *slot, int track)
{ // line 24, offset 0x80055064
	/* begin block 1 */
		// Start line: 25
		// Start offset: 0x80055064
		// Variables:
			struct AadSeqEvent seqEvent; // stack offset -16
			unsigned char *seqData; // $a2
			unsigned long deltaTime; // $v1
			int c; // $a0
			int n; // $a3
			int i; // $a0
	/* end block 1 */
	// End offset: 0x80055254
	// End Line: 99

	/* begin block 2 */
		// Start line: 48
	/* end block 2 */
	// End Line: 49

	return 0;
}


// decompiled code
// original method signature: 
// void /*$ra*/ aadExecuteEvent(struct AadSeqEvent *event /*$s0*/, struct _AadSequenceSlot *slot /*$s1*/)
 // line 103, offset 0x8005525c
	/* begin block 1 */
		// Start line: 104
		// Start offset: 0x8005525C
		// Variables:
	// 		int eventType; // $v1
	/* end block 1 */
	// End offset: 0x800552E8
	// End Line: 123

	/* begin block 2 */
		// Start line: 210
	/* end block 2 */
	// End Line: 211

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void aadExecuteEvent(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  code *pcVar1;
  
  if ((event->statusByte & 0x80) == 0) {
    aadSubstituteVariables(event,slot);
    if (0x4d < event->statusByte) {
      return;
    }
    pcVar1 = (code *)midiMetaEventFunction[(uint)event->statusByte & 0x7f];
  }
  else {
    pcVar1 = *(code **)((int)midiEventFunction + ((uint)(event->statusByte >> 2) & 0x1c));
  }
  (*pcVar1)(event,slot);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiNoteOff(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 127, offset 0x800552fc
	/* begin block 1 */
		// Start line: 258
	/* end block 1 */
	// End Line: 259

	/* begin block 2 */
		// Start line: 262
	/* end block 2 */
	// End Line: 263

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void midiNoteOff(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiNoteOn(struct AadSeqEvent *event /*$fp*/, struct _AadSequenceSlot *slot /*$s5*/)
 // line 139, offset 0x80055304
	/* begin block 1 */
		// Start line: 140
		// Start offset: 0x80055304
		// Variables:
	// 		struct AadProgramAtr *progAtr; // $s4
	// 		struct AadToneAtr *toneAtrTbl; // $v1
	// 		struct AadSynthVoice *voice; // $s0
	// 		int channel; // $s7
	// 		int midiNote; // $s6
	// 		int transposedNote; // stack offset -56
	// 		int t; // $s2
	// 		int dynBank; // stack offset -52

		/* begin block 1.1 */
			// Start line: 220
			// Start offset: 0x800554E4
			// Variables:
		// 		unsigned long waveStartAddr; // $a1
		/* end block 1.1 */
		// End offset: 0x8005562C
		// End Line: 245
	/* end block 1 */
	// End offset: 0x80055648
	// End Line: 249

	/* begin block 2 */
		// Start line: 282
	/* end block 2 */
	// End Line: 283

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void midiNoteOn(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  byte bVar1;
  char cVar2;
  byte bVar3;
  uchar uVar4;
  int iVar5;
  ulong *puVar6;
  AadSynthVoice *voice;
  int iVar7;
  ulong waveStartAddr;
  uint *puVar8;
  AadToneAtr *toneAtr;
  int iVar9;
  uint uVar10;
  AadProgramAtr *progAtr;
  uint uVar11;
  uint uVar12;
  uint local_38;
  
  uVar12 = (uint)event->statusByte & 0xf;
  iVar7 = (int)&(slot->tempo).currentTick + uVar12;
  if ((((int)(uint)slot->channelMute >> uVar12 & 1U) == 0) && (*(char *)(iVar7 + 0x590) != -1)) {
    bVar1 = event->dataByte[0];
    uVar11 = (uint)bVar1;
    iVar9 = 0;
    if (event->dataByte[1] == '\0') {
      iVar7 = 0x1dc;
      do {
        iVar5 = aadMem;
        puVar8 = (uint *)(aadMem + iVar7);
        if ((((uint)*(byte *)(puVar8 + 2) == (slot->slotID | uVar12)) &&
            ((uint)*(byte *)((int)puVar8 + 10) == uVar11)) &&
           ((cVar2 = *(char *)(aadMem + iVar9 + 0x47c), cVar2 != '\0' && (cVar2 != '\x02')))) {
          *(uint *)(aadMem + 0x4c4) = *(uint *)(aadMem + 0x4c4) | *puVar8;
          *(uint *)(iVar5 + 0x4c8) = *(uint *)(iVar5 + 0x4c8) & ~*puVar8;
          *(undefined *)(puVar8 + 2) = 0xff;
        }
        iVar9 = iVar9 + 1;
        iVar7 = iVar7 + 0x1c;
      } while (iVar9 < 0x18);
    }
    else {
      local_38 = uVar11;
      if (((int)(uint)slot->ignoreTranspose >> uVar12 & 1U) == 0) {
        local_38 = uVar11 + *(byte *)(iVar7 + 0x5c0) & 0xff;
      }
      iVar9 = (int)&(slot->tempo).currentTick + uVar12;
      bVar3 = *(byte *)(iVar9 + 0x560);
      iVar7 = aadMem + (uint)bVar3 * 4;
      if (*(int *)(iVar7 + 0x500) == 2) {
        progAtr = (AadProgramAtr *)(*(int *)(iVar7 + 0x4d8) + (uint)*(byte *)(iVar9 + 0x590) * 8);
        uVar10 = (uint)progAtr->firstTone;
        if (uVar10 < uVar10 + progAtr->numTones) {
          puVar6 = (ulong *)((int)&(slot->tempo).currentTick + uVar12 * 2);
          toneAtr = (AadToneAtr *)(uVar10 * 0x10 + *(int *)(iVar7 + 0x4e0));
          do {
            if (((toneAtr->minNote <= uVar11) && (uVar11 <= toneAtr->maxNote)) &&
               (voice = aadAllocateVoice((uint)toneAtr->priority), voice != (AadSynthVoice *)0x0)) {
              waveStartAddr =
                   *(ulong *)((int)toneAtr->waveIndex * 4 +
                             *(int *)(aadMem + (uint)bVar3 * 4 + 0x4e8));
              if ((toneAtr->pitchBendMax == '\0') || (*(short *)(puVar6 + 0x15c) == 0x2000)) {
                aadPlayTone(toneAtr,waveStartAddr,progAtr,local_38,(uint)(byte)event->dataByte[1],
                            (uint)*(byte *)(iVar9 + 0x5a0),(uint)*(byte *)(iVar9 + 0x5b0),
                            (uint)slot->slotVolume,*slot->masterVolPtr,voice,0);
                voice->handle = 0;
              }
              else {
                aadPlayTonePitchBend
                          (toneAtr,waveStartAddr,progAtr,local_38,(uint)(byte)event->dataByte[1],
                           (uint)*(byte *)(iVar9 + 0x5a0),(uint)*(byte *)(iVar9 + 0x5b0),
                           (uint)slot->slotVolume,*slot->masterVolPtr,voice,
                           (uint)*(ushort *)(puVar6 + 0x15c));
                voice->handle = 0;
              }
              voice->voiceID = slot->slotID | (byte)uVar12;
              uVar4 = toneAtr->priority;
              voice->note = bVar1;
              voice->priority = uVar4;
              voice->program = *(uchar *)(iVar9 + 0x590);
              voice->volume = event->dataByte[1];
              voice->updateVol = *(uchar *)(iVar9 + 0x5a0);
              uVar4 = *(uchar *)(iVar9 + 0x5b0);
              voice->progAtr = progAtr;
              voice->toneAtr = toneAtr;
              voice->pan = uVar4;
            }
            uVar10 = uVar10 + 1;
            toneAtr = toneAtr + 1;
          } while ((int)uVar10 < (int)((uint)progAtr->firstTone + (uint)progAtr->numTones));
        }
      }
    }
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadUpdateChannelVolPan(struct _AadSequenceSlot *slot /*$s4*/, int channel /*$s5*/)
 // line 253, offset 0x80055678
	/* begin block 1 */
		// Start line: 254
		// Start offset: 0x80055678
		// Variables:
	// 		struct AadSynthVoice *voice; // $s0
	// 		int i; // $s2
	// 		struct AadVolume newVoiceVol; // stack offset -40

		/* begin block 1.1 */
			// Start line: 267
			// Start offset: 0x80055718
			// Variables:
		// 		unsigned long tmp; // $v1
		/* end block 1.1 */
		// End offset: 0x80055718
		// End Line: 267

		/* begin block 1.2 */
			// Start line: 268
			// Start offset: 0x80055780
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.2 */
		// End offset: 0x80055780
		// End Line: 268

		/* begin block 1.3 */
			// Start line: 269
			// Start offset: 0x800557FC
			// Variables:
		// 		unsigned long tmp; // $v1
		/* end block 1.3 */
		// End offset: 0x800557FC
		// End Line: 269

		/* begin block 1.4 */
			// Start line: 270
			// Start offset: 0x80055864
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.4 */
		// End offset: 0x80055864
		// End Line: 270

		/* begin block 1.5 */
			// Start line: 270
			// Start offset: 0x80055864
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v0
		/* end block 1.5 */
		// End offset: 0x80055864
		// End Line: 270

		/* begin block 1.6 */
			// Start line: 270
			// Start offset: 0x80055864
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.6 */
		// End offset: 0x80055864
		// End Line: 270

		/* begin block 1.7 */
			// Start line: 270
			// Start offset: 0x80055864
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v0
		/* end block 1.7 */
		// End offset: 0x80055864
		// End Line: 270
	/* end block 1 */
	// End offset: 0x800559B4
	// End Line: 282

	/* begin block 2 */
		// Start line: 583
	/* end block 2 */
	// End Line: 584

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void aadUpdateChannelVolPan(_AadSequenceSlot *slot,int channel)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int vNum;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  short local_28;
  short local_26;
  
  vNum = 0;
  iVar4 = (int)&(slot->tempo).currentTick + channel;
  iVar5 = 0x1dc;
  do {
    iVar3 = aadMem + iVar5;
    if ((uint)*(byte *)(iVar3 + 8) == ((uint)slot->slotID | channel)) {
      local_28 = (ushort)*(byte *)(iVar3 + 0xe) * (ushort)*(byte *)(iVar3 + 0xe);
      local_26 = (ushort)*(byte *)(iVar3 + 0xe) * (ushort)*(byte *)(iVar3 + 0xe);
      if ((*(uint *)(aadMem + 0x24) & 1) == 0) {
        bVar1 = *(byte *)(iVar4 + 0x5b0);
        if (bVar1 < 0x41) {
          if (bVar1 < 0x3f) {
            local_26 = (short)((int)((int)local_28 * (uint)*(byte *)(iVar4 + 0x5b0) *
                                    (uint)*(byte *)(iVar4 + 0x5b0)) >> 0xc);
          }
        }
        else {
          local_28 = (short)((int)local_26 * (0x7f - (uint)bVar1) * (0x7f - (uint)bVar1) >> 0xc);
        }
      }
      uVar2 = (uint)*(byte *)(*(int *)(iVar3 + 0x14) + 2);
      iVar6 = uVar2 * uVar2;
      local_28 = (short)((uint)(local_28 * iVar6) >> 0xe);
      local_26 = (short)((uint)(local_26 * iVar6) >> 0xe);
      if ((*(uint *)(aadMem + 0x24) & 1) == 0) {
        bVar1 = *(byte *)(*(int *)(iVar3 + 0x14) + 3);
        if (bVar1 < 0x41) {
          if (bVar1 < 0x3f) {
            uVar2 = (uint)*(byte *)(*(int *)(iVar3 + 0x14) + 3);
            local_26 = (short)((int)((int)local_28 * uVar2 * uVar2) >> 0xc);
          }
        }
        else {
          local_28 = (short)((int)local_26 * (0x7f - (uint)bVar1) * (0x7f - (uint)bVar1) >> 0xc);
        }
      }
      iVar6 = (uint)*(byte *)(iVar4 + 0x5a0) * (uint)*(byte *)(iVar4 + 0x5a0);
      uVar2 = (uint)*(byte *)(*(int *)(iVar3 + 0x18) + 4);
      iVar7 = uVar2 * uVar2;
      iVar8 = (uint)slot->slotVolume * (uint)slot->slotVolume;
      iVar9 = *slot->masterVolPtr * *slot->masterVolPtr;
      SpuSetVoiceVolume(vNum,(short)((uint)((short)((uint)((short)((uint)((short)((uint)(local_28 *
                                                                                        iVar6) >>
                                                                                 0xe) * iVar7) >>
                                                                  0xe) * iVar8) >> 0xe) * iVar9) >>
                                    0xe),
                        (short)((uint)((short)((uint)((short)((uint)((short)((uint)(local_26 * iVar6
                                                                                   ) >> 0xe) * iVar7
                                                                    ) >> 0xe) * iVar8) >> 0xe) *
                                      iVar9) >> 0xe));
      *(undefined *)(iVar3 + 0xf) = *(undefined *)(iVar4 + 0x5a0);
      *(undefined *)(iVar3 + 0x10) = *(undefined *)(iVar4 + 0x5b0);
    }
    vNum = vNum + 1;
    iVar5 = iVar5 + 0x1c;
  } while (vNum < 0x18);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadUpdateSlotVolPan(struct _AadSequenceSlot *slot /*$s1*/)
 // line 286, offset 0x800559d8
	/* begin block 1 */
		// Start line: 287
		// Start offset: 0x800559D8
		// Variables:
	// 		struct AadSynthVoice *voice; // $t0
	// 		int channel; // $t1
	// 		int i; // $s0
	// 		struct AadVolume newVoiceVol; // stack offset -24

		/* begin block 1.1 */
			// Start line: 302
			// Start offset: 0x80055A6C
			// Variables:
		// 		unsigned long tmp; // $v1
		/* end block 1.1 */
		// End offset: 0x80055A6C
		// End Line: 302

		/* begin block 1.2 */
			// Start line: 303
			// Start offset: 0x80055AD4
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.2 */
		// End offset: 0x80055AD4
		// End Line: 303

		/* begin block 1.3 */
			// Start line: 304
			// Start offset: 0x80055B50
			// Variables:
		// 		unsigned long tmp; // $v1
		/* end block 1.3 */
		// End offset: 0x80055B50
		// End Line: 304

		/* begin block 1.4 */
			// Start line: 305
			// Start offset: 0x80055BB8
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.4 */
		// End offset: 0x80055BB8
		// End Line: 305

		/* begin block 1.5 */
			// Start line: 305
			// Start offset: 0x80055BB8
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v0
		/* end block 1.5 */
		// End offset: 0x80055BB8
		// End Line: 305

		/* begin block 1.6 */
			// Start line: 305
			// Start offset: 0x80055BB8
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v1
		/* end block 1.6 */
		// End offset: 0x80055BB8
		// End Line: 305

		/* begin block 1.7 */
			// Start line: 305
			// Start offset: 0x80055BB8
			// Variables:
		// 		unsigned long masterVolumeSquared; // $v0
		/* end block 1.7 */
		// End offset: 0x80055BB8
		// End Line: 305
	/* end block 1 */
	// End offset: 0x80055CF4
	// End Line: 314

	/* begin block 2 */
		// Start line: 686
	/* end block 2 */
	// End Line: 687

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void aadUpdateSlotVolPan(_AadSequenceSlot *slot)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  int vNum;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short local_18;
  short local_16;
  
  vNum = 0;
  iVar5 = 0x1dc;
  do {
    iVar3 = aadMem + iVar5;
    if (((uint)*(byte *)(iVar3 + 8) & 0xf0) == (uint)slot->slotID) {
      local_18 = (ushort)*(byte *)(iVar3 + 0xe) * (ushort)*(byte *)(iVar3 + 0xe);
      local_16 = (ushort)*(byte *)(iVar3 + 0xe) * (ushort)*(byte *)(iVar3 + 0xe);
      uVar4 = (uint)*(byte *)(iVar3 + 8) & 0xf;
      if ((*(uint *)(aadMem + 0x24) & 1) == 0) {
        iVar6 = (int)&(slot->tempo).currentTick + uVar4;
        bVar1 = *(byte *)(iVar6 + 0x5b0);
        if (bVar1 < 0x41) {
          if (bVar1 < 0x3f) {
            uVar2 = (uint)*(byte *)(iVar6 + 0x5b0);
            local_16 = (short)((int)((int)local_18 * uVar2 * uVar2) >> 0xc);
          }
        }
        else {
          local_18 = (short)((int)local_16 * (0x7f - (uint)bVar1) * (0x7f - (uint)bVar1) >> 0xc);
        }
      }
      uVar2 = (uint)*(byte *)(*(int *)(iVar3 + 0x14) + 2);
      iVar6 = uVar2 * uVar2;
      local_18 = (short)((uint)(local_18 * iVar6) >> 0xe);
      local_16 = (short)((uint)(local_16 * iVar6) >> 0xe);
      if ((*(uint *)(aadMem + 0x24) & 1) == 0) {
        bVar1 = *(byte *)(*(int *)(iVar3 + 0x14) + 3);
        if (bVar1 < 0x41) {
          if (bVar1 < 0x3f) {
            uVar2 = (uint)*(byte *)(*(int *)(iVar3 + 0x14) + 3);
            local_16 = (short)((int)((int)local_18 * uVar2 * uVar2) >> 0xc);
          }
        }
        else {
          local_18 = (short)((int)local_16 * (0x7f - (uint)bVar1) * (0x7f - (uint)bVar1) >> 0xc);
        }
      }
      iVar6 = (uint)slot->volume[uVar4] * (uint)slot->volume[uVar4];
      uVar4 = (uint)*(byte *)(*(int *)(iVar3 + 0x18) + 4);
      iVar3 = uVar4 * uVar4;
      iVar7 = (uint)slot->slotVolume * (uint)slot->slotVolume;
      iVar8 = *slot->masterVolPtr * *slot->masterVolPtr;
      SpuSetVoiceVolume(vNum,(short)((uint)((short)((uint)((short)((uint)((short)((uint)(local_18 *
                                                                                        iVar6) >>
                                                                                 0xe) * iVar3) >>
                                                                  0xe) * iVar7) >> 0xe) * iVar8) >>
                                    0xe),
                        (short)((uint)((short)((uint)((short)((uint)((short)((uint)(local_16 * iVar6
                                                                                   ) >> 0xe) * iVar3
                                                                    ) >> 0xe) * iVar7) >> 0xe) *
                                      iVar8) >> 0xe));
    }
    vNum = vNum + 1;
    iVar5 = iVar5 + 0x1c;
  } while (vNum < 0x18);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadUpdateChannelPitchBend(struct _AadSequenceSlot *slot /*$s5*/, int channel /*$s6*/)
 // line 318, offset 0x80055d0c
	/* begin block 1 */
		// Start line: 319
		// Start offset: 0x80055D0C
		// Variables:
	// 		struct AadSynthVoice *voice; // $a0
	// 		int i; // $s0
	// 		int finePitch; // $a1
	// 		int newPitch; // $a1
	// 		int pitchWheelPos; // $s2
	// 		int pitchIndex; // $a0
	// 		long pitchValueBendAmount; // $a2
	/* end block 1 */
	// End offset: 0x80055EA0
	// End Line: 366

	/* begin block 2 */
		// Start line: 785
	/* end block 2 */
	// End Line: 786

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void aadUpdateChannelPitchBend(_AadSequenceSlot *slot,int channel)

{
  int iVar1;
  short sVar2;
  int iVar3;
  int vNum;
  int iVar4;
  int iVar5;
  int iVar6;
  
  vNum = 0;
  iVar4 = 0x1dc;
  iVar5 = (uint)slot->pitchWheel[channel] - 0x2000;
  do {
    iVar1 = aadMem + iVar4;
    if ((uint)*(byte *)(iVar1 + 8) == ((uint)slot->slotID | channel)) {
      iVar3 = *(int *)(iVar1 + 0x14);
      if (*(byte *)(iVar3 + 9) != 0) {
        iVar6 = 0x2000 / (int)(uint)*(byte *)(iVar3 + 9);
        iVar1 = ((uint)*(byte *)(iVar1 + 10) - ((uint)*(byte *)(iVar3 + 4) - 0x3c)) + iVar5 / iVar6;
        if ((*(byte *)(iVar3 + 5) & 0x80) == 0) {
          sVar2 = aadPitchTable[iVar1] +
                  (ushort)(aadStepsPerCent[iVar1] * 100 * (uint)*(byte *)(iVar3 + 5) >> 0x17);
        }
        else {
          sVar2 = aadPitchTable[iVar1] -
                  (ushort)(aadStepsPerCent[iVar1] * 100 * (0x100 - (uint)*(byte *)(iVar3 + 5)) >>
                          0x17);
        }
        SpuSetVoicePitch(vNum,sVar2 + (short)(((int)aadStepsPerSemitone[iVar1] * (iVar5 % iVar6)) /
                                             iVar6));
      }
    }
    vNum = vNum + 1;
    iVar4 = iVar4 + 0x1c;
  } while (vNum < 0x18);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiPolyphonicAftertouch(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 369, offset 0x80055ec8
	/* begin block 1 */
		// Start line: 974
	/* end block 1 */
	// End Line: 975

	/* begin block 2 */
		// Start line: 975
	/* end block 2 */
	// End Line: 976

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void midiPolyphonicAftertouch(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlChange(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 374, offset 0x80055ed0
	/* begin block 1 */
		// Start line: 375
		// Start offset: 0x80055ED0
		// Variables:
	// 		int controlNumber; // $v0
	/* end block 1 */
	// End offset: 0x80055ED0
	// End Line: 375

	/* begin block 2 */
		// Start line: 984
	/* end block 2 */
	// End Line: 985

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void midiControlChange(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  (*(code *)midiControlFunction[(uint)(byte)event->dataByte[0] & 0xf])();
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiProgramChange(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 385, offset 0x80055f10
	/* begin block 1 */
		// Start line: 387
		// Start offset: 0x80055F10
		// Variables:
	// 		int channel; // $v0
	/* end block 1 */
	// End offset: 0x80055F10
	// End Line: 389

	/* begin block 2 */
		// Start line: 1007
	/* end block 2 */
	// End Line: 1008

	/* begin block 3 */
		// Start line: 1008
	/* end block 3 */
	// End Line: 1009

	/* begin block 4 */
		// Start line: 1010
	/* end block 4 */
	// End Line: 1011

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void midiProgramChange(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  slot->currentProgram[(uint)event->statusByte & 0xf] = event->dataByte[0];
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiChannelAftertouch(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 396, offset 0x80055f28
	/* begin block 1 */
		// Start line: 1030
	/* end block 1 */
	// End Line: 1031

	/* begin block 2 */
		// Start line: 1031
	/* end block 2 */
	// End Line: 1032

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void midiChannelAftertouch(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiPitchWheelControl(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a3*/)
 // line 401, offset 0x80055f30
	/* begin block 1 */
		// Start line: 402
		// Start offset: 0x80055F30
		// Variables:
	// 		int channel; // $a1
	/* end block 1 */
	// End offset: 0x80055F30
	// End Line: 402

	/* begin block 2 */
		// Start line: 1040
	/* end block 2 */
	// End Line: 1041

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void midiPitchWheelControl(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  uint channel;
  
  channel = (uint)event->statusByte & 0xf;
  slot->pitchWheel[channel] =
       (ushort)(byte)event->dataByte[0] | (ushort)(byte)event->dataByte[1] << 7;
  aadUpdateChannelPitchBend(slot,channel);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiMetaEvent(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 413, offset 0x80055f78
	/* begin block 1 */
		// Start line: 1067
	/* end block 1 */
	// End Line: 1068

	/* begin block 2 */
		// Start line: 1070
	/* end block 2 */
	// End Line: 1071

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void midiMetaEvent(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlBankSelect(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 421, offset 0x80055f80
	/* begin block 1 */
		// Start line: 1083
	/* end block 1 */
	// End Line: 1084

	/* begin block 2 */
		// Start line: 1104
	/* end block 2 */
	// End Line: 1105

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void midiControlBankSelect(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlVolume(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a2*/)
 // line 446, offset 0x80055f88
	/* begin block 1 */
		// Start line: 447
		// Start offset: 0x80055F88
		// Variables:
	// 		int channel; // $a1
	/* end block 1 */
	// End offset: 0x80055FC8
	// End Line: 458

	/* begin block 2 */
		// Start line: 1133
	/* end block 2 */
	// End Line: 1134

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void midiControlVolume(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  uint channel;
  
  channel = (uint)event->statusByte & 0xf;
  slot->volume[channel] = event->dataByte[1];
  if (((int)(uint)slot->enableSustainUpdate >> channel & 1U) != 0) {
    aadUpdateChannelVolPan(slot,channel);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlPan(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a2*/)
 // line 461, offset 0x80055fd8
	/* begin block 1 */
		// Start line: 462
		// Start offset: 0x80055FD8
		// Variables:
	// 		int channel; // $a1
	/* end block 1 */
	// End offset: 0x80056018
	// End Line: 473

	/* begin block 2 */
		// Start line: 1164
	/* end block 2 */
	// End Line: 1165

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void midiControlPan(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  uint channel;
  
  channel = (uint)event->statusByte & 0xf;
  slot->panPosition[channel] = event->dataByte[1];
  if (((int)(uint)slot->enableSustainUpdate >> channel & 1U) != 0) {
    aadUpdateChannelVolPan(slot,channel);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlCallback(struct AadSeqEvent *event /*$a3*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 476, offset 0x80056028
	/* begin block 1 */
		// Start line: 477
		// Start offset: 0x80056028
	/* end block 1 */
	// End offset: 0x8005605C
	// End Line: 488

	/* begin block 2 */
		// Start line: 1195
	/* end block 2 */
	// End Line: 1196

	/* begin block 3 */
		// Start line: 1198
	/* end block 3 */
	// End Line: 1199

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void midiControlCallback(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  if (*(code **)(&DAT_00001bf8 + aadMem) != (code *)0x0) {
    (**(code **)(&DAT_00001bf8 + aadMem))
              (*(undefined4 *)(aadMem + 0x1c00),(uint)slot->thisSlotNumber,
               (uint)event->statusByte & 0xf,(uint)(byte)event->dataByte[1]);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ midiControlDummy(struct AadSeqEvent *event /*$a0*/, struct _AadSequenceSlot *slot /*$a1*/)
 // line 491, offset 0x8005606c
	/* begin block 1 */
		// Start line: 1228
	/* end block 1 */
	// End Line: 1229

	/* begin block 2 */
		// Start line: 1229
	/* end block 2 */
	// End Line: 1230

/* File: C:\kain2\game\PSX\AADSEQEV.C */

void midiControlDummy(AadSeqEvent *event,_AadSequenceSlot *slot)

{
  return;
}





